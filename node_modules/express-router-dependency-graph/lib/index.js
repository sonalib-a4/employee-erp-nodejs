"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeDependency = void 0;
const dependency_cruiser_1 = require("dependency-cruiser");
const parser_1 = require("@babel/parser");
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const esquery_1 = __importDefault(require("esquery"));
// @ts-ignore
const markdown_table_1 = __importDefault(require("markdown-table"));
const findRouting = async (filePath) => {
    try {
        const fileContent = await promises_1.default.readFile(filePath, "utf-8");
        const AST = (0, parser_1.parse)(fileContent, {
            sourceType: "module",
            plugins: ["jsx", "typescript"]
        });
        const search = (method, AST) => {
            const selector = `CallExpression:has(MemberExpression > Identifier[name="${method}"])`;
            const results = (0, esquery_1.default)(AST, selector);
            // router.{get,post,delete,put,use}
            return results.flatMap((node) => {
                var _a, _b, _c, _d;
                const pathValue = node.arguments[0] !== undefined &&
                    node.arguments[0].type === "StringLiteral" &&
                    node.arguments[0].value;
                if (!pathValue) {
                    return []; // skip: it will only includes middleware
                }
                const middlewareArguments = method === "use"
                    ? // @ts-ignore
                        (_b = (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.slice(1)) !== null && _b !== void 0 ? _b : []
                    : // @ts-ignore
                        (_d = (_c = node.arguments) === null || _c === void 0 ? void 0 : _c.slice(1, node.arguments.length - 1)) !== null && _d !== void 0 ? _d : [];
                const middlewares = middlewareArguments.map((arg) => {
                    return fileContent.slice(arg.start, arg.end);
                });
                return [
                    {
                        method,
                        path: pathValue,
                        middlewares,
                        // @ts-ignore
                        range: [node.start, node.end],
                        // @ts-ignore
                        loc: node.loc
                    }
                ];
            });
        };
        const methods = ["get", "post", "delete", "put", "use"];
        return methods.flatMap((method) => {
            return search(method, AST);
        });
    }
    catch (_a) {
        return [];
    }
};
const toAbsolute = (f) => {
    return path_1.default.resolve(process.cwd(), f);
};
async function analyzeDependency({ outputFormat, rootDir, rootBaseUrl = "", includeOnly, doNotFollow }) {
    const ROOT_DIR = rootDir;
    const hasImportExpress = (dep) => {
        return ((dep.dependencyTypes.includes("npm") || dep.dependencyTypes.includes("npm-dev")) && dep.module === "express");
    };
    const underTheRoot = (module) => {
        return toAbsolute(module.source).startsWith(ROOT_DIR);
    };
    const hasModuleImportExpress = (module) => {
        return module.dependencies.some((dep) => hasImportExpress(dep));
    };
    const toRelative = (f) => {
        return path_1.default.relative(ROOT_DIR, toAbsolute(f));
    };
    const ARRAY_OF_FILES_AND_DIRS_TO_CRUISE = [ROOT_DIR];
    const cruiseResult = (0, dependency_cruiser_1.cruise)(ARRAY_OF_FILES_AND_DIRS_TO_CRUISE, {
        includeOnly,
        doNotFollow
    });
    if (typeof cruiseResult.output !== "object") {
        throw new Error("NO OUTPUT");
    }
    const modules = cruiseResult.output.modules.filter(hasModuleImportExpress).filter(underTheRoot);
    const allResults = await Promise.all(modules.map(async (mo) => {
        return {
            filePath: toAbsolute(mo.source),
            routers: await findRouting(toAbsolute(mo.source))
        };
    }));
    if (outputFormat === "markdown") {
        const table = [["File", "Method", "Routing", "Middlewares", "FilePath"]];
        for (const result of allResults) {
            table.push([`${rootBaseUrl}${toRelative(result.filePath)}`]);
            result.routers.forEach((router) => {
                table.push([
                    "",
                    router.method,
                    router.path,
                    router.middlewares.join(", ").split(/\r?\n/g).join(" "),
                    `${rootBaseUrl}${toRelative(result.filePath)}#L${router.loc.start.line}-L${router.loc.end.line}`
                ]);
            });
        }
        return (0, markdown_table_1.default)(table);
    }
    else {
        return allResults;
    }
}
exports.analyzeDependency = analyzeDependency;
//# sourceMappingURL=index.js.map